#!/usr/bin/perl -w
#
# Daybo Logic Podcast downloader
# Copyright (c) 2012-2014, David Duncan Ross Palmer (M6KVM), Daybo Logic
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
#     * Neither the name of the Daybo Logic nor the names of its contributors
#       may be used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

package main; # TODO: Only one package?  Should be more OOP!
use LWP::UserAgent;
use XML::Feed;
use Data::Dumper;
use Config::IniFiles;
use Getopt::Std;
use URI::Escape;
use IO::Interactive qw(is_interactive);
use DBI;
use POSIX ":sys_wait_h";

use strict;
use warnings;
use diagnostics;

use constant DEV_NULL => '/dev/null';

my $Debug = 0;
my $Quiet = 0;
my $File = '';

sub fileFromURI($) {
	my $Url = shift;
	return undef if ( !$Url );
	my @uri_parts = split('/', $Url);
	return $uri_parts[-1];
}

sub readFeed($$) {
	my @entries = ( );
	my ( $Feeds, $Feed ) = @_;
	my ( $Url, $Name ) = ( $Feed->{rss}, $Feed->{name} );
	my $feed = XML::Feed->parse(URI->new($Url));
	if ( !$feed ) {
		printf(STDERR "Stream %s error: %s\n", $Name, $@);
		return @entries;
	}

	foreach my $entry ($feed->entries) {
		my $enclosure = $entry->{'entry'}->{'enclosure'};
		my $uriDecoded = uri_unescape($enclosure->{'url'});
		my $filename = fileFromURI($uriDecoded);
		push(@entries, {
			filename => $filename,
			uri      => $uriDecoded,
			title    => $entry->title,
			type     => $enclosure->{'type'},
			length   => $enclosure->{'length'}
		}) if ( $filename );
	}
	return @entries;
}

sub rSleep($) {
	my $time = shift;
	return 0 unless ( $time );

	if ( $time =~ m/^(\d+)r$/o ) {
		$time = int(rand($1)) + 1;
	} elsif ( $time !~ m/^\d+$/o ) {
		return -1;
	}

	printf(STDERR "Sleeping %u seconds\n", $time)
		if ( $Debug );

	sleep($time);
	return $time;
}

sub downloadStream($$$) {
	my ( $ua, $f, %get_params, $is_interactive );
	my $http_resp;
	my $local_length = 0;
	my ( $Feeds, $entry, $Name ) = @_;
	my $rsleep = $Feeds->{$Name}->{rsleep} || $Feeds->{main}->{RSLEEP};
	my $retries = $Feeds->{$Name}->{retries} || $Feeds->{main}->{RETRIES};
	my $local_podcast = $Feeds->{$Name}->{localpath} . '/' . $entry->{filename};
	if ( -f $local_podcast ) {
		$local_length = (stat($local_podcast))[7];
		if ( !$entry->{length} || $local_length == $entry->{length} ) {
			printf(STDERR "%s already exists\n", $local_podcast) unless ( $Quiet );
			return;
		}
	}
	$is_interactive = is_interactive();
	$ua = LWP::UserAgent->new(
		show_progress => $is_interactive && !$Quiet,
		agent => 'dlpodget'
	);
	printf(STDERR "Downloading %s ... ", $entry->{uri}) if ( !$is_interactive && !$Quiet );

	unless ( $Feeds->{main}->{NOOP} ) {
		if ( open($f, '>>:raw', $local_podcast) ) {
			binmode($f);
		} else {
			printf(STDERR "Local failure on stream %s -- %s: %s\n", $Name, $local_podcast, $!);
			return;
		}
	}
	%get_params = (
		'Range' => "bytes=$local_length-"
	) if ( $local_length );

	my $tries = 1 + ($retries || 0);
	do {
		$http_resp = $ua->get(
			$entry->{uri},
			%get_params,
			':content_cb' => sub {
				my ( $chunk ) = @_;
				print $f $chunk unless ( $Feeds->{main}->{NOOP} );
			}
		);
		rSleep($rsleep) if ( ($tries-1) && $http_resp->code() != 200 );
	} while ( $http_resp->code() != 200 && --$tries );

	close($f) if ( !$Feeds->{main}->{NOOP} );
	printf(STDERR "done.\n") if ( !$is_interactive && !$Quiet );
}

sub processTags($$) {
	my ( $Feeds, $V ) = @_;
	my $tagRx = qr/^\$([A-Z0-9]+)/o;
	my $avoid = 0;
	while ( (my $idx = index($V, '$', $avoid)) > -1 ) { # Find remaining user-variable references
		my $var = substr($V, $idx);
		if ( $var =~ $tagRx ) {
			my $v = $Feeds->{main}->{ uc($1) };
			warn(sprintf('%s -> %s', $1, $v || '(undef)')) if ( $Debug );
			if ( !defined($v) ) {
				$avoid = $idx+1;
				next;
			}
			substr($V, $idx, length($1)+1, $v);
		} else {
			$avoid++;
		}
	}
	return $V;
}

sub child($$$$) {
	my ( $DB, $FeedKey, $Feeds, $Feed ) = @_;
	my @entries = readFeed($Feeds, $Feed);
	foreach my $entry ( @entries ) {
		print STDERR 'Processing entry: ' . Dumper $entry if ( $Debug );
		downloadStream($Feeds, $entry, $Feed->{name});
		dbUpdateStream($DB, $FeedKey, $entry) if ( $DB );
	}
}

sub db() {
	my $dbh;

	return undef if ( $File eq DEV_NULL() );
	$dbh = DBI->connect("DBI:SQLite:$File");
	if ( $dbh ) {
		$dbh->do(
			'CREATE TABLE IF NOT EXISTS feeds (
				id INTEGER PRIMARY KEY NOT NULL,
				name CHAR(16) UNIQUE NOT NULL,
				last_check_t INTEGER NOT NULL default 0
			)'
		);
		$dbh->do(
			'CREATE TABLE IF NOT EXISTS streams (
				id INTEGER PRIMARY KEY NOT NULL,
				feed_id INTEGER NOT NULL,
				remotefn CHAR(32) NOT NULL,
				localfn CHAR(32),
				remotelen INTEGER,
				UNIQUE(feed_id, remotefn) ON CONFLICT REPLACE
			)'
		);
	}
	return $dbh;
}

my %_dbUpdateFeed = (
	'get_feed_id' => undef,
	'ins_feed' => undef,
	'upd_feed' => undef
);
sub dbUpdateFeed($$) {
	my $ret = 0;
	my $sth;
	my ( $DB, $Name ) = @_;

	# Prepare all of the possible statements
	if ( !$_dbUpdateFeed{'get_feed_id'} ) {
		my $sth = $DB->prepare('SELECT id FROM feeds WHERE name = ?');
		$_dbUpdateFeed{'get_feed_id'} = $sth if ( $sth );
	}

	if ( !$_dbUpdateFeed{'ins_feed'} ) {
		my $sth = $DB->prepare('
			INSERT INTO feeds (
				last_check_t, name
			) VALUES(
				?, ?
			)'
		);
		$_dbUpdateFeed{'ins_feed'} = $sth if ( $sth );
	}

	if ( !$_dbUpdateFeed{'upd_feed'} ) {
		my $sth = $DB->prepare('UPDATE feeds SET last_check_t = ? WHERE id = ?');
		$_dbUpdateFeed{'upd_feed'} = $sth if ( $sth );
	}

	# Execute needed statements
	$_dbUpdateFeed{'get_feed_id'}->execute($Name);
	my $ref = $_dbUpdateFeed{'get_feed_id'}->fetchrow_hashref();
	if ( $ref->{id} ) { # Does feed exist?
		# Yes, the feed exists.
		$ret = $ref->{id};
		$_dbUpdateFeed{'upd_feed'}->execute(time(), $ret);
	} else { # Feed does not exist
		my $sth = $_dbUpdateFeed{'ins_feed'}->execute(time(), $Name);
		$ret = $DB->last_insert_id(undef, undef, undef, undef);
	}

	die('Assertion failure') if ( !$ret );
	return $ret;
}

my %_dbUpdateStream = (
	'repl_into_stream' => undef
);
sub dbUpdateStream($$$) {
	my $ret = 0;
	my ( $DB, $FeedKey, $Entry ) = @_;
	if ( !$_dbUpdateStream{'repl_into_stream'} ) {
		my $sth = $DB->prepare(
			'INSERT OR REPLACE INTO streams (
				feed_id, remotefn, remotelen, localfn
			) VALUES(
				?, ?, ?, ?
			)'
		);
		$_dbUpdateStream{'repl_into_stream'} = $sth if ( $sth );
	}
	if ( $_dbUpdateStream{'repl_into_stream'} ) {
		$ret = $_dbUpdateStream{'repl_into_stream'}->execute(
			$FeedKey,
			$Entry->{filename},
			$Entry->{length},
			$Entry->{filename}
		);
	}
	return $ret;
}

sub banner($) {
	my $showLicense = shift;
	my $doneShbang = 0;
	my $blankLines = 0;

	if ( open(my $f, '<', $0) ) {
		while ( my $l = <$f> ) {
			last if ( $l !~ s/^\#//o ); # Strip comments

			if ( !$doneShbang && $l =~ m/^\!/ ) { # Skip shband
				$doneShbang++;
				next;
			}
			if ( !$showLicense ) {
				last if ( $blankLines == 2 );
				$blankLines++ if ( $l =~ m/^\s*$/ );
			}

			print $l;
		}
		close($f);
		print(" Use -L to see full license terms.\n") if ( !$showLicense );
		print("\n");
	}
}

sub syntax() {
	printf("%s [-c n...] [-f <file>] [-n <feed>] -d -q\n\n", $0);

	print("-n <feed>\n");
	print("\tOnly download one feed, not all those in the config\n\n");

	print("-f <file>\n");
	print("\tOverride the database file (default \"$ENV{HOME}/.dlpodget.db)\"\n\n");

	print("-q\n");
	print("\tQuiet mode - no output (except errors)\n\n");

	print("-c <n...>\n");
	print("\tOverride maximum children in the feed download pool (see config)\n\n");

	print("-h / -?\n");
	print("\tSyntax help (this)\n\n");
	# TODO: You want more specific help by using -h and another option.

	print("-d\n");
	print("\tdebug\n\n");

	return 0;
}

sub main() {
	my $proctitle = $0; # Save original process title
	my $conf;
	my @entries = ( );
	my @defKeys;
	my %feeds = ( );
	my %opts = ( );
	my %pids;
	my @confFiles = (
		'dlpodget.rc',
		"$ENV{HOME}/.dlpodget.rc"
	);

	return 1 if ( !getopts('Lf:qc:dn:h?', \%opts) );
	$Quiet = 1 if ( $opts{'q'} );
	banner($opts{'L'}) unless ( $Quiet );
	return syntax() if ( $opts{'h'} || $opts{'?'} );
	$Debug = 1 if ( $opts{'d'} );
	$File  = ( $opts{'f'} ) ? ( $opts{'f'} ) : ( "$ENV{HOME}/.dlpodget.db" );
	print(STDERR "Explicit debug mode enabled by -d\n") if ( $Debug );
	print(STDERR "Quiet mode enabled by -q\n") if ( $Debug );
	if ( $opts{'f'} ) {
		my $n = ' (null device)';
		$n = '' if ( $File ne DEV_NULL() );
		printf(STDERR "Overridden database with -f %s%s\n", $File, $n)
	}

	foreach my $confFile ( @confFiles ) {
		next unless ( -f $confFile );
		$conf = Config::IniFiles->new(-file => $confFile, -commentchar => ';');
		if ( !$conf ) {
			print(STDERR "Fault with $confFile: " . join(',', @Config::IniFiles::errors) . "\n");
			return 1;
		}
		last;
	}

	if ( $conf && (@defKeys = $conf->Parameters('main')) ) {
		if ( !$conf->val('main', 'enable', 1) ) {
			print(STDERR "Configuration disabled.\n") unless ( $Quiet );
			$conf = undef;
		}
	}
	if ( $conf ) {
		my %reserveSec = map {  $_ => 1 } ( 'main', 'paths' ); # Reserved section names
		my ( @sections, $secC );
		@sections = $conf->Sections();
		$secC = scalar(@sections);

		# First load the generation configuration information
		# Include environment variables.
		foreach my $ek ( keys(%ENV) ) {
			$feeds{main}->{ uc($ek) } = $ENV{$ek};
		}
		if ( scalar(@defKeys) ) {
			foreach my $mk ( @defKeys ) {
				$feeds{main}->{ uc($mk) } = processTags(\%feeds, $conf->val('main', $mk));
			}
			# Set debug flag via config if it existed.
			if ( $feeds{main}->{DEBUG} ) {
				$Debug = $feeds{main}->{DEBUG};
				printf(STDERR "Set Debug via config: %s\n", $Debug);
			}
		}

		if ( 'paths' ~~ @sections ) { # Has a paths section?
			my @secKeys;
			if ( (@secKeys = $conf->Parameters('paths')) ) {
				foreach my $pk ( @secKeys ) {
					$feeds{main}->{ uc($pk) } = $conf->val('paths', $pk);
				}
				# For backward compatibility, set localpfx with [paths] root
				$feeds{main}->{'LOCALPFX'} = $feeds{main}->{'ROOT'}
					if ( $feeds{main}->{'ROOT'} );
			}
		}

		for ( my $secI = 0; $secI < $secC; $secI++ ) {
			my ( @secKeys, $keyC );
			next if ( $opts{'n'} && $sections[$secI] ne $opts{'n'} );
			@secKeys = $conf->Parameters($sections[$secI]);
			$keyC = scalar(@secKeys);
			foreach ( my $keyI = 0; $keyI < $keyC; $keyI++ ) {
				next if ( $reserveSec{$sections[$secI]} ); # Skip reserved sections
				my $v = $conf->val($sections[$secI], $secKeys[$keyI]);
				$v = processTags(\%feeds, $v);
				printf(
					STDERR
					'[%s] %s -> %s'."\n",
					$sections[$secI],
					$secKeys[$keyI],
					$v
				) if ( $Debug );
				$feeds{ $sections[$secI] }->{ $secKeys[$keyI] } = $v;
			}
		}
	}

	if ( defined($opts{'c'}) ) {
		my $max_children_opt = int($opts{'c'});
		if ( $Debug ) {
			my $msg;
			if ( defined($feeds{main}->{MAXCHILDREN}) ) {
				$msg = sprintf(
					"Overriding config maxchildren %u via -c %u\n",
					$feeds{main}->{MAXCHILDREN}, $max_children_opt
				);
			} else {
				$msg = sprintf("Setting maxchildren via -c %u\n", $max_children_opt);
			}
			print(STDERR $msg);
		}
		$feeds{main}->{MAXCHILDREN} = $max_children_opt;
	}

	$0 = "$proctitle [MASTER]" if ( $feeds{main}->{MAXCHILDREN} != 0 );
	my $db = db();
	foreach my $feedName ( keys(%feeds) ) {
		my $feed_key;
		my $reaped_pid;
		my $child_limit_reached = 0;
		my $feed = $feeds{$feedName};
		next if ( !$feed->{enable} );
		next if ( !$feed->{download} );
		$feed->{name} = $feedName;
		$feed_key = dbUpdateFeed($db, $feed->{name}) if ( $db );
		if ( $feeds{main}->{MAXCHILDREN} == 0 ) { # Master performs downloads
			$0 = "$proctitle [$feedName]";
			child($db, $feed_key, \%feeds, $feed);
			next;
		} elsif ( $feeds{main}->{MAXCHILDREN} < 0 || scalar(keys(%pids)) < $feeds{main}->{MAXCHILDREN} ) {
			sleep($feeds{_main}->{CHILDDELAY}) if ( $feeds{_main}->{CHILDDELAY} && scalar(keys(%pids)) );
			my $pid = fork();
			die "cannot fork: $!" if ( !defined($pid) );
			if ( $pid == 0 ) { # Child process
				$0 = "$proctitle [$feedName]";
				child($db, $feed_key, \%feeds, $feed);
				exit(0); # Children should not return
			} else {
				$pids{$pid} = $feedName;
			}
		} else {
			warn "Pending (child limit reached)." unless ( $Quiet );
			$child_limit_reached = 1;
		}

		if ( $child_limit_reached ) {
			$reaped_pid = wait();
		} else {
			$reaped_pid = waitpid(-1, WNOHANG); # Any children finished?
			next if ( $reaped_pid <= 0 ); # No, carry on.
		}

		# A child returned, remove it from the PID list
		die 'Internal error' if ( !exists($pids{$reaped_pid}) );
		delete($pids{$reaped_pid});

		redo if ( $child_limit_reached );
	}
	while ( scalar(keys(%pids)) ) {
		my $pid = wait();
		last if ( $pid == -1 );
		delete($pids{$pid});
	}

	return 0;
}

exit(main()) if ( !caller() );
1;
