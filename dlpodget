#!/usr/bin/perl
#
# Daybo Logic Podcast downloader
# Copyright (C) 2012-2024, Ducan Ross Palmer (M6KVM, 2E0EOL), all rights reserved.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
#     * Neither the name of the Daybo Logic nor the names of its contributors
#       may be used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

package main;
use lib './lib';
use Config::IniFiles;
#use LWP::Protocol::Net::Curl MAX_RECV_SPEED_LARGE => 10240;
use File::Path qw(make_path);
use Dlpodget::DIC;
use Dlpodget::Config;
use Dlpodget::TagProcessor;
use Dlpodget::Muadeeb;
use LWP::UserAgent;
use XML::Feed;
use Data::Dumper;
use Getopt::Std;
use URI::Escape;
use IO::Interactive qw(is_interactive);
use DBI;
use POSIX ":sys_wait_h";
use Readonly;
use File::Find;

use strict;
use warnings;

#Readonly my $RATE_LIMIT_LIMIT  => 4; # Limit to 4KB per second
#Readonly my $RATE_LIMIT_PERIOD => 30; # Period in seconds over which to calculate average

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

sub wanted;

Readonly my $DEV_NULL => '/dev/null';

Readonly my $CODEC_MP3   => 1;
Readonly my $CODEC_MIN   => $CODEC_MP3;
Readonly my $CODEC_PCM   => 2;
Readonly my $CODEC_FLAC  => 3;
Readonly my $CODEC_OGG   => 4;
Readonly my $CODEC_MAX   => $CODEC_OGG;

Readonly my $CODEC_ERR_UNSUPPORTED_CODEC       => 1;
Readonly my $CODEC_ERR_UNSUPPORTED_TRANSLATION => 2;
Readonly my $CODEC_ERR_REDUNDANT               => 3;

Readonly my $CODEC_TRANSLATION_OUTPUT_FIRST    => 1;
Readonly my $CODEC_TRANSLATION_OUTPUT_LAST     => 2;

Readonly my $CODEC_TRANSLATION_ENCODE          => 1;
Readonly my $CODEC_TRANSLATION_DECODE          => 2;

my $Log = undef;
my $OutputHandle = undef;
my $Quiet = 0;
my $File = '';
my $globalTagProcessor = Dlpodget::TagProcessor->new(); # TODO: Automatic via dic?
my $dic; # THIS IS THE FUTURE!

sub wanted {
	my ($dev,$ino,$mode,$nlink,$uid,$gid);

	(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
	(int(-M _) > 3) && # FIXME: Three days hard-coded!  DANGER  Will Robinson (also, no noop support)
	-f _ &&
	(unlink($_) || warn "$name: $!\n");
}

sub codecInfo {
	my ($codec) = @_;
	my %codecs = (
		$CODEC_MP3 => {
			'fileExt' => 'mp3',
			'label'   => 'mp3',
			'desc'    => 'MPEG II Layer III',
		},
		$CODEC_PCM => {
			'fileExt' => 'wav',
			'label'   => 'wav',
			'desc'    => 'PCM Wave',
		},
		$CODEC_FLAC => {
			'fileExt' => 'flac',
			'label'   => 'flac',
			'desc'    => 'Flac',
		},
		$CODEC_OGG => {
			'fileExt' => 'ogg',
			'label'   => 'ogg',
			'desc'    => 'Ogg Vorbis',
		},
	);
	return $codecs{$codec};
}

sub validateDirection {
	my ($direction) = @_;
	if (defined($direction) && $direction =~ m/^(\d)$/) {
		return $direction if ($direction >= 1 && $direction <= 2);
	}
	die('Direction must be encode or decode');
}

sub validateFilename {
	my ($fileName) = @_;
	die 'Must supply filename' if (!$fileName);
	die 'File does not exist' unless (-f $fileName);
	return;
}

sub validateCodec {
	my (@params) = @_;
	my $codecInfo = codecInfo($params[0]);
	return $codecInfo if ($codecInfo);

	die('Unknown codec');
}

sub transcodePCM {
	# Nb. 'file', $CODEC_OGG, $CODEC_TRANSLATION_ENCODE means convert a .wav to .ogg
	my ($fileName, $codec, $direction) = @_;

	validateFilename($fileName);
	validateCodec($codec);
	validateDirection($direction);

	#my %translations
	return;
}

sub translationInfo {
	my ($fromCodec, $toCodec) = @_;
	my ($fCodec, $tCodec);

	my %translations = (
		$CODEC_MP3 => {
			$CODEC_MP3  => undef,
			$CODEC_PCM  => {
				cmd   => 'mpg321 "%s" -w "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_LAST,
			},
			$CODEC_FLAC => '',
			$CODEC_OGG  => '',
		},
		$CODEC_PCM => {
			$CODEC_MP3 => {
				cmd   => 'lame "%s" "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_LAST,
			},
			$CODEC_PCM  => undef,
			$CODEC_FLAC => {
				cmd   => 'flac -o "%s" "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_FIRST,
			},
			$CODEC_OGG => {
				cmd   => 'oggenc -o "%s" "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_FIRST,
			},
		}, $CODEC_FLAC => {
			$CODEC_MP3  => '',
			$CODEC_PCM  => {
				cmd   => 'flac -d -o "%s" "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_FIRST,
			},
			$CODEC_FLAC => undef,
			$CODEC_OGG  => ''
		}, $CODEC_OGG => {
			$CODEC_MP3  => '',
			$CODEC_PCM  => {
				cmd   => 'oggdec -o "%s" "%s"',
				order => $CODEC_TRANSLATION_OUTPUT_FIRST,
			},
			$CODEC_FLAC => '',
			$CODEC_OGG  => undef,
		}
	);

	$fCodec = $translations{$fromCodec};
	return $CODEC_ERR_UNSUPPORTED_CODEC unless ($fCodec);
	return $CODEC_ERR_UNSUPPORTED_TRANSLATION
	    unless (exists($fCodec->{$toCodec}));

	$tCodec = $fCodec->{$toCodec};
	return $CODEC_ERR_REDUNDANT unless ($tCodec);

	return $fCodec;
}

=head2 fileFromURI

This simple function returns the filename from a URI, eg.
http://host.domain.dom/path/file.html would return file.html
If no URL, or an invalid path is passed, undef is returned.

=cut

sub fileFromURI {
	my ($url) = @_;
	return unless ($url);
	my @uri_parts = split('/', $url);
	return $uri_parts[-1];
}

sub FeedCache {
	my ($Name, $Url) = @_;
	my ($resp, $ua);
	my $cacheFileName = "$ENV{HOME}/.cache/dlpodget/$Name.rss";
	if (-f $cacheFileName) { # Already cached.
		$dic->logger->debug("Feed $Name has been satisfied by existing cache - $cacheFileName");
		return $cacheFileName;
	}

	$Url = URI->new($Url);
	$ua = LWP::UserAgent->new();

	$resp = $ua->get($Url);
	if ($resp->is_success()) {
		if (open(my $f, '>:raw', $cacheFileName)) {
			print $f $resp->content();
			close($f);
		} else {
			$dic->logger->error(sprintf('Local failure on feed %s -- %s: %s', $Name, $cacheFileName, $!));
			$cacheFileName = undef; # Force URL instead
		}
	} else {
		$dic->logger->trace($resp->status_line);
		$cacheFileName = undef;
	}

	if ($cacheFileName) {
		$dic->logger->debug("Feed $Name has been satisfied by newly written cache file - $cacheFileName");
		return $cacheFileName;
	}

	$dic->logger->debug("Feed $Name has no cache available");
	return $Url;
}

sub readFeed {
	my ($Feeds, $Feed) = @_;

	my ($Url, $Name) = ($Feed->{rss}, $Feed->{name});
	my $feedCache = FeedCache($Name, $Url);
	my $feed;
	eval {
		$feed = XML::Feed->parse($feedCache);
	};
	if (my $evalError = $@) {
		$dic->logger->error($evalError);
		return ( );
	}

	$Name ||= 'Untitled feed';
	my @entries = ( );
	if (!$feed) {
		$dic->logger->error(sprintf('Stream %s error: %s', $Name, $@));
		return @entries;
	}

	downloadLog('feed', $Url);
	foreach my $entry ($feed->entries) {
		my $enclosure = $entry->{'entry'}->{'enclosure'};
		my $uriDecoded = uri_unescape($enclosure->{'url'});
		my $filename = fileFromURI($uriDecoded);
		push(@entries, {
			localFilename  => $filename,
			remoteFilename => $filename,
			uri            => $uriDecoded,
			title          => $entry->title,
			type           => $enclosure->{'type'},
			length         => $enclosure->{'length'}
		}) if ($filename);
	}
	return @entries;
}

#TODO: Move these out of global scope!
my $chunks;
my $total_size;
my %get_params;
sub Chunk {
	my ($chunk) = @_;
	my $chunk_len = length($chunk);
	print $OutputHandle $chunk;
	$dic->logger->debug(sprintf(
		'Now we have %u chunks. This chunk was %u in size',
		++$chunks, $chunk_len,
	));
	$total_size += $chunk_len;
}

sub NullChunk {
	return;
}

# FIXME: Is this related to a duff merge?
#	$ua->get($log_feed_notify_uri);
#	printf(STDERR "Posted to %s\n", $log_feed_notify_uri);
#}

sub downloadLog {
	my ($type, $url) = @_;
	$dic->logger->info("Downloading $type: $url");
	return;
}

sub downloadStream {
	my ($Feeds, $entry, $Name, $tries) = @_;

	my $http_resp;
	my $local_length = 0;
	my $rsleep = $Feeds->{$Name}->{rsleep}   || $Feeds->{main}->value('rsleep');
	my $retries = $Feeds->{$Name}->{retries} || $Feeds->{main}->value('retries');
	my $chunkCB = \&Chunk;
	my $notify = $Feeds->{$Name}->{notify} || $Feeds->{main}->{NOTIFY};
	my $maxcount = $Feeds->{$Name}->{maxcount} || $Feeds->{main}->{MAXCOUNT};
	my $local_podcast = join('/', $Feeds->{$Name}->{localpath}, $entry->{localFilename});
	my $maxage = $Feeds->{$Name}->{maxage} || $Feeds->{main}->{MAXAGE};

	if (-f $local_podcast) {
		$local_length = (stat($local_podcast))[7];
		if (!$entry->{length} || $local_length == $entry->{length}) {
			$dic->logger->debug(sprintf('%s already exists', $local_podcast)) unless ($Quiet);
			return;
		} elsif ($local_length > $entry->{length}) {
			# Downloaded too much, this might mean we were downloading the stream
			# from two concurrent downloaders, we should just kill the file and redo.
			if ($Feeds->{main}->{NOOP}) {
				$dic->logger->debug("Local file $local_podcast is bigger than upstream, but not deleted due to noop mode");
			} elsif (unlink($local_podcast) == 1) {
				$dic->logger->warn("Deleted $local_podcast (bigger than upstream's), will download again");
				$local_length = 0;
			} else {
				$dic->logger->warn("Can't delete oversized file $local_podcast: $!, skipped.");
				return;
			}
		}
	}

	my $is_interactive = is_interactive();
	my $ua = LWP::UserAgent->new(
		show_progress => $is_interactive && !$Quiet,
		agent => 'dlpodget',
	);
	$dic->logger->info(sprintf('Downloading %s ... ', $entry->{uri})) if (!$Quiet);
	$dic->logger->debug(sprintf('Setting timeout %u and retries %d',
	    $Feeds->{main}->{TIMEOUT}, $Feeds->{main}->{MAXTRIES}));

	$ua->timeout($Feeds->{main}->{TIMEOUT});
	$tries = $Feeds->{main}->{MAXTRIES};

	unless ($Feeds->{main}->value('noop')) {
		make_path($Feeds->{$Name}->{localpath});
		if (open($OutputHandle, '>>:raw', $local_podcast)) {
			binmode($OutputHandle);
		} else {
			$dic->logger->error(sprintf('Local failure on stream %s -- %s: %s', $Name, $local_podcast, $!));
			return;
		}
	}
	$chunkCB = \&NullChunk if ($Feeds->{main}->{NOOP});
	if ($local_length) {
		%get_params = (
			'Range' => "bytes=$local_length-",
		);
	} else {
		downloadLog('stream', $entry->{uri});
	}

	$tries = 1 + ($retries || 0);
	my $paul = Dlpodget::Muadeeb->new();
	do {
		$http_resp = $ua->get(
			$entry->{uri},
			%get_params,
			':content_cb' => sub {
				my ( $chunk ) = @_;
				#print $f $chunk unless ( $Feeds->{main}->{NOOP} ); # FIXME; $f out of scope
		#':content_cb' => $chunkCB
			},
		);
		$paul->rSleep($rsleep) if (($tries-1) && $http_resp->code() != 200);
	} while ($http_resp->code() != 200 && --$tries);

	close($OutputHandle) if (!$Feeds->{main}->{NOOP});
	$OutputHandle = undef;

	#close($f) if ( !$Feeds->{main}->value('noop') ); # FIXME: $f out of scope
	printf(STDERR "done.\n") if (!$is_interactive && !$Quiet);

	Notify($local_podcast) if ($notify);
	return;
}

#sub processTagsOld($$) {
#	my ( undef, $V ) = @_; # Feeds deprecated in this function
#	my $tagRx = qr/^\$([A-Z0-9]+)/o;
#	my $avoid = 0;
#	while ( (my $idx = index($V, '$', $avoid)) > -1 ) { # Find remaining user-variable references
#		my $var = substr($V, $idx);
#		if ( $var =~ $tagRx ) {
#			#my $v = $Feeds->{main}->{ uc($1) };
#			#my $v = $globalTagProcessor->value(uc($1));
#			warn(sprintf('%s -> %s', $1, $v || '(undef)'));
#			if ( !defined($v) ) {
#				$avoid = $idx+1;
#				next;
#			}
#			substr($V, $idx, length($1)+1, $v);
#		} else {
#			$avoid++;
#		}
#	}
#	return $V;
#}

sub processTags {
	my ($testData, $V) = @_;

	while (my ($k, $v) = each(%{$testData->{mappings}})) {
		$globalTagProcessor->assoc($k, $v);
	}

	return $globalTagProcessor->result($V);
}

sub cleanupStreams {
	my ($Feeds, $entry, $Name) = @_;

	my $maxcount = $Feeds->{$Name}->{maxcount} || $Feeds->{main}->{MAXCOUNT};
	my $maxage = $Feeds->{$Name}->{maxage} || $Feeds->{main}->{MAXAGE};

	return if (!$maxage && !$maxcount); # Nothing for us to do

	print Dumper File::Find::find({wanted => \&wanted}, $Feeds->{$Name}->{localpath});
	#TODO

	return;
}

sub child {
	my ($DB, $FeedKey, $Feeds, $Feed) = @_;

	my @entries = readFeed($Feeds, $Feed);
	foreach my $entry (@entries) {
		$dic->logger->debug('Processing entry: ' . Dumper $entry);
		cleanupStreams($Feeds, $entry, $Feed->{name});
		downloadStream($Feeds, $entry, $Feed->{name});
		dbUpdateStream($DB, $FeedKey, $entry) if ($DB);
	}

	return;
}

sub db {
	my $dbh;

	return if ($File eq $DEV_NULL);

	$dbh = DBI->connect("DBI:SQLite:$File");
	if ($dbh) {
		$dbh->do(
			'CREATE TABLE IF NOT EXISTS feeds (
				id INTEGER PRIMARY KEY NOT NULL,
				name CHAR(16) UNIQUE NOT NULL,
				last_check_t INTEGER NOT NULL default 0
			)'
		);
		$dbh->do(
			'CREATE TABLE IF NOT EXISTS streams (
				id INTEGER PRIMARY KEY NOT NULL,
				feed_id INTEGER NOT NULL,
				remotefn CHAR(32) NOT NULL,
				localfn CHAR(32),
				remotelen INTEGER,
				UNIQUE(feed_id, remotefn) ON CONFLICT REPLACE
			)'
		);
	}
	return $dbh;
}

my %_dbUpdateFeed = (
	get_feed_id => undef,
	ins_feed    => undef,
	upd_feed    => undef,
);
#	} # Duff merge?
sub dbUpdateFeed {
	my ($DB, $Name) = @_;
	my $ret = 0;
	my $sth;

	# Prepare all of the possible statements
	if (!$_dbUpdateFeed{'get_feed_id'}) {
		my $sth = $DB->prepare('SELECT id FROM feeds WHERE name = ?');
		$_dbUpdateFeed{'get_feed_id'} = $sth if ( $sth );
	}

	if (!$_dbUpdateFeed{'ins_feed'}) {
		my $sth = $DB->prepare('
			INSERT INTO feeds (
				last_check_t, name
			) VALUES(
				?, ?
			)'
		);
		$_dbUpdateFeed{'ins_feed'} = $sth if ($sth);
	}

	if (!$_dbUpdateFeed{'upd_feed'}) {
		my $sth = $DB->prepare('UPDATE feeds SET last_check_t = ? WHERE id = ?');
		$_dbUpdateFeed{'upd_feed'} = $sth if ( $sth );
	}

	# Execute needed statements
	$_dbUpdateFeed{'get_feed_id'}->execute($Name);
	my $ref = $_dbUpdateFeed{'get_feed_id'}->fetchrow_hashref();
	if ($ref->{id}) { # Does feed exist?
		# Yes, the feed exists.
		$ret = $ref->{id};
		$_dbUpdateFeed{'upd_feed'}->execute(time(), $ret);
	} else { # Feed does not exist
		my $sth = $_dbUpdateFeed{'ins_feed'}->execute(time(), $Name);
		$ret = $DB->last_insert_id(undef, undef, undef, undef);
	}

	die('Assertion failure') unless ($ret);
	return $ret;
}

my %_dbUpdateStream = (
	repl_into_stream => undef,
);
sub dbUpdateStream {
	my ($DB, $FeedKey, $Entry) = @_;
	my $ret = 0;

	if (!$_dbUpdateStream{'repl_into_stream'}) {
		my $sth = $DB->prepare(
			'INSERT OR REPLACE INTO streams (
				feed_id, remotefn, remotelen, localfn
			) VALUES(
				?, ?, ?, ?
			)'
		);
		$_dbUpdateStream{'repl_into_stream'} = $sth if ($sth);
	}

	if ($_dbUpdateStream{'repl_into_stream'}) {
		$ret = $_dbUpdateStream{'repl_into_stream'}->execute(
			$FeedKey,
			$Entry->{remoteFilename},
			$Entry->{length},
			$Entry->{localFilename}
		);
	}

	return $ret;
}

sub Notify {
	my ($localFeed) = @_;

	system(
		"echo \"Feed $localFeed\" | mail -s \"New feed available\" palmer\@overchat.org"
	);

	return;
}

sub banner {
	my ($showLicense) = @_;
	my $doneShbang = 0;
	my $blankLines = 0;

	if (open(my $f, '<', $0)) {
		while (my $l = <$f>) {
			last if ($l !~ s/^\#//o); # Strip comments

			if (!$doneShbang && $l =~ m/^\!/) { # Skip shbang
				$doneShbang++;
				next;
			}

			if (!$showLicense) {
				last if ($blankLines == 2);
				$blankLines++ if ($l =~ m/^\s*$/);
			}

			print $l;
		}
		close($f);
		print(" Use -L to see full license terms.\n") unless ($showLicense);
		print("\n");
	}

	return;
}

sub syntax {
	printf("%s [-C config] [-c n...] [-f <file>] [-n <feed>] -d -q\n\n", $0);

	print("-C <config>\n");
	print("\tSpecify a specific, user-defined config file\n\n");

	print("-n <feed>\n");
	print("\tOnly download one feed, not all those in the config\n\n");

	print("-f <file>\n");
	print("\tOverride the database file (default \"$ENV{HOME}/.dlpodget.db)\"\n\n");

	print("-q\n");
	print("\tQuiet mode - no output (except errors)\n\n");

	print("-c <n...>\n");
	print("\tOverride maximum children in the feed download pool (see config)\n\n");

	print("-h / -?\n");
	print("\tSyntax help (this)\n\n");
	# TODO: You want more specific help by using -h and another option.

	print("-d\n");
	print("\tdebug\n\n");

	return 0;
}

sub listHasMember {
	my ($needle, @hayStack) = @_;

	foreach my $member (@hayStack) {
		if (!defined($needle) && !defined($member)) {
			return 1;
		} elsif (!defined($needle) || !defined($member)) {
			return 0;
		} else {
			return 1 if ($needle eq $member);
		}
	}

	return 0;
}

sub initDic {
	$dic = Dlpodget::DIC->new();
	$globalTagProcessor->dic($dic);
	return;
}

sub installSignalHandlers {
	$SIG{__WARN__} = sub {
		my (@args) = @_;
		$dic->logger->warn(@args);
	};

	$SIG{__DIE__} = sub {
		my (@args) = @_;
		$dic->logger->fatal(@args);
	};

	return;
}

sub main {
	my $proctitle = $0; # Save original process title
	my @entries = ( );
	my @defKeys;
	my %feeds = ( );
	my %opts = ( );
	my %pids;
	my ($streamsEnabledCount, $streamsDefinedCount) = (0, 0);
	my @confFiles = (
		'dlpodget.rc',
		"$ENV{HOME}/.dlpodget.rc",
	);

	initDic();
	installSignalHandlers();
	return 1 unless (getopts('C:Lf:qc:n:h?', \%opts));
	@confFiles = ($opts{C}) if ($opts{C});
	$Quiet = 1 if ($opts{q});
	banner($opts{L}) unless ($Quiet);
	return syntax() if ($opts{h} || $opts{'?'});
	$File  = $opts{f} ? $opts{f} : "$ENV{HOME}/.dlpodget.db";
	$dic->logger->debug('Quiet mode enabled by -q') if ($Quiet);
	if ($opts{f}) {
		my $n = ' (null device)';
		$n = '' if ($File ne $DEV_NULL);
		$dic->logger->debug("Overridden database with -f $File${n}");
	}

	$dic->config->confFiles(\@confFiles);
	$dic->config->load();

	if ($dic->config->ini && (@defKeys = $dic->config->ini->Parameters('main'))) {
		unless ($dic->config->ini->val('main', 'enable', 1)) {
			$dic->logger->debug('Configuration disabled.') unless ($Quiet);
			$dic->config->disable();
		}
	}

	$feeds{main} = Dlpodget::TagProcessor->new({ dic => $dic });
	if ($dic->config->ini) {
		my %reserveSec = map { $_ => 1 } ('main', 'paths'); # Reserved section names
		my (@sections, $secC);
		@sections = $dic->config->ini->Sections() if ($dic->config->ini);
		$secC = scalar(@sections);

		# First load the generation configuration information
		# Include environment variables.
		foreach my $ek (keys(%ENV)) {
			$feeds{main}->assoc(uc($ek), $ENV{$ek});
		}
		if (scalar(@defKeys)) {
			foreach my $mk ( @defKeys ) {
				# FIXME: This is still busted
				#$globalTagProcessor->assoc(uc($mk), $globalTagProcessor->result($dic->config->ini->val('main', $mk)));
				$feeds{main}->{ uc($mk) } = processTags(\%feeds, $dic->config->ini->val('main', $mk));
			}
		}

		$dic->config->initConfigDefaults(\%feeds);
		if (listHasMember('paths', @sections)) { # Has a paths section?
			my @secKeys;
			if ((@secKeys = $dic->config->ini->Parameters('paths'))) {
				foreach my $pk (@secKeys) {
					$feeds{main}->assoc(uc($pk), $dic->config->ini->val('paths', $pk));
				}
				# For backward compatibility, set localpfx with [paths] root
				if ($feeds{main}->value('root')) {
					$feeds{main}->assoc('localpfx', $feeds{main}->value('root'));
				}
			}
		}

		for (my $secI = 0; $secI < $secC; $secI++) {
			my (@secKeys, $keyC);
			next if ($opts{n} && $sections[$secI] ne $opts{n});
			@secKeys = $dic->config->ini->Parameters($sections[$secI]);
			$keyC = scalar(@secKeys);
			foreach (my $keyI = 0; $keyI < $keyC; $keyI++) {
				next if ($reserveSec{$sections[$secI]}); # Skip reserved sections
				my $v = $dic->config->ini->val($sections[$secI], $secKeys[$keyI]);
				#$v = processTags(\%feeds, $v);
				$dic->logger->trace(sprintf(
					'[%s] %s -> %s',
					$sections[$secI],
					$secKeys[$keyI],
					$v,
				));
				$feeds{ $sections[$secI] }->{ $secKeys[$keyI] } = $v;
			}
		}
	}

	if (defined($opts{c})) {
		my $max_children_opt = int($opts{c});
		my $msg;
		if (defined($feeds{main}->value('maxchildren'))) {
			$msg = sprintf(
				"Overriding config maxchildren %u via -c %u\n",
				$feeds{main}->value('maxchildren'), $max_children_opt,
			);
		} else {
			$msg = sprintf("Setting maxchildren via -c %u\n", $max_children_opt);
		}
		$dic->logger->debug($msg);
		$feeds{main}->assoc('maxchildren', $max_children_opt);
	}

	$0 = "$proctitle [MASTER]" if ($feeds{main}->value('maxchildren') != 0);
	my $db = db();
	foreach my $feedName (keys(%feeds)) {
		my $feed_key;
		my $reaped_pid;
		my $child_limit_reached = 0;
		my $feed = $feeds{$feedName};
		$dic->config->initFeedDefaults(\%feeds, $feed);
		$streamsDefinedCount++ if ($feed->{rss});
		next unless ($feed->{enable});
		next unless ($feed->{download});
		$feed->{name} = $feedName;
		$feed_key = dbUpdateFeed($db, $feed->{name}) if ($db);
		$streamsEnabledCount++;
		if ($feeds{main}->{MAXCHILDREN} == 0) { # Master performs downloads
			$streamsEnabledCount++;
			$0 = "$proctitle [$feedName]";
			child($db, $feed_key, \%feeds, $feed);
			next;
		} elsif ($feeds{main}->{MAXCHILDREN} < 0 || scalar(keys(%pids)) < $feeds{main}->{MAXCHILDREN}) {
			sleep($feeds{main}->{CHILDDELAY}) if ($feeds{main}->{CHILDDELAY} && scalar(keys(%pids)));
			my $pid = fork();
			die("cannot fork: $!") if (!defined($pid));
			if ($pid == 0) { # Child process
				$0 = "$proctitle [$feedName]";
				child($db, $feed_key, \%feeds, $feed);
				exit(0); # Children should not return
			} else {
				$pids{$pid} = $feedName;
			}
		} else {
			$child_limit_reached = 1;
			$dic->logger->trace(sprintf(
				'Pending, child limit (%d) reached. (max %d)',
				scalar(keys(%pids)),
				$feeds{main}->{MAXCHILDREN},
			));
		}

		if ($child_limit_reached) {
			$reaped_pid = wait();
		} else {
			$reaped_pid = waitpid(-1, WNOHANG); # Any children finished?
			next if ($reaped_pid <= 0); # No, carry on.
		}

		# A child returned, remove it from the PID list
		die('Internal error') if (!exists($pids{$reaped_pid}));
		delete($pids{$reaped_pid});

		redo if ($child_limit_reached);
	}

	while (scalar(keys(%pids))) {
		my $pid = wait();
		last if ($pid == -1);
		delete($pids{$pid});
	}

	unless ($streamsDefinedCount) {
		$dic->logger->error('No valid streams defined');
		return 1;
	}

	unless ($streamsEnabledCount) {
		$dic->logger->info('No enabled streams');
		return 0;
	}

	unless ($streamsDefinedCount) {
		$dic->logger->error('No valid streams defined');
		return 1;
	}

	unless ($streamsEnabledCount) {
		$dic->logger->info('No enabled streams');
		return 0;
	}

	close($Log) if ($Log);
	return 0;
}

exit(main()) unless (caller());
1;
